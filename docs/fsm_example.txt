#include <iostream>
#include <algorithm>
#include <vector>
#include <functional>

#define STATE(_name_, _input_, _next_) case _name_: _next_ = On##_name_##(_input_); break
#define STATE_DECL(_name_) State On##_name_
#define STATE_IMPL(_class_, _name_) State _class_::On##_name_

enum State 
{
    BEGIN,
    WAIT_COMM,
    IN_SLINE_COMM,
    IN_MLINE_COMM,
    EXIT_MLINE_COMM,
    END,
    ERROR
};

struct FSM 
{
    State Accept(char c);

    void Reset() {
        state = BEGIN;
        nextState = BEGIN;
        token = "";
    }

    State state{ BEGIN };
    State nextState{ BEGIN };
    std::string token{};

private:
    STATE_DECL(BEGIN) (char);
    STATE_DECL(WAIT_COMM) (char);
    STATE_DECL(IN_SLINE_COMM) (char);
    STATE_DECL(IN_MLINE_COMM) (char);
    STATE_DECL(EXIT_MLINE_COMM) (char);
};

STATE_IMPL(FSM, BEGIN) (char c)
{
	if (c == '/') {
		return WAIT_COMM;
	} else {
        return BEGIN;
    }
}

STATE_IMPL(FSM, WAIT_COMM) (char c)
{
	if (c == '*') {
		return IN_MLINE_COMM;
	} else if (c == '/') {
		return IN_SLINE_COMM;
	} else {
		return ERROR;
	}
}

STATE_IMPL(FSM, IN_SLINE_COMM) (char c)
{
	token += c;
	if (c == '\n') {
		token.pop_back();
		return END;
	} 
    return IN_SLINE_COMM;
}

STATE_IMPL(FSM, IN_MLINE_COMM) (char c)
{
	token += c;
	if (c == '*') {
		return EXIT_MLINE_COMM;
	} 
    return IN_MLINE_COMM;
}

STATE_IMPL(FSM, EXIT_MLINE_COMM) (char c)
{
	token += c;
	if (c == '/') {
		/* Pop "\*\/" */
		token.pop_back();
		token.pop_back();
		return END;
	} 
	else {
		return IN_MLINE_COMM;
	}
}

State FSM::Accept(char c)
{
    switch (state) {
        STATE(BEGIN, c, nextState);
        STATE(WAIT_COMM, c, nextState);
        STATE(IN_SLINE_COMM, c, nextState);
        STATE(IN_MLINE_COMM, c, nextState);
        STATE(EXIT_MLINE_COMM, c, nextState);
    }

    state = nextState;
    return state;
}

int main()
{
    FSM fsm{};
    std::string source = 
		"// Hello single /3 /4 /5 /* */ line comment\n"
		"/* Hello multi* line* comment/ 0\n"
		" aaa */\n" 
		"/* Hello multi line\n"
		"comment 1 */\n"
		"/* Hello multi* line* comment/ 2\n"
		" bbb ccc\n" 
		" bbb ccc */\n" 
        "/* Hello multi* line* comment/ 3*/\n";

    for (auto it = source.cbegin(); it != source.cend(); ++it) {
        State state = fsm.Accept(*it);
        // std::cout << "ch=" << *it << ", state=" << (int)state << '\n';
        if (state == ERROR) {
            return 1;
        } else if (state == END) {
            std::cout << fsm.token << std::endl;
            fsm.Reset();
        }
    }

    std::vector<int> v{ 1,2,3,4,5 };
    int a{};

    std::sort(v.begin(), v.end(), 
              [&](int lhs, int rhs) -> bool {
                  int b = a;
				  return rhs < lhs;
			  });

    std::function<bool(int, int)> f = 
		  [&](int lhs, int rhs) -> bool {
			  int b = a;
			  return rhs < lhs;
		  };

    return 0;
}
