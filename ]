#pragma once

#include "Common/Math/Transform.hpp"
#include "NamedObject.hpp"
#include "SceneObject.hpp"

namespace mm
{

class SceneObject;

/* NOTE: world transform calculation needs to be updated manually. */

class Node : public NamedObject
{
public:
	Node(StringView name) : NamedObject{ name } {}
	//void OnUpdate(f32 deltaTime);

	void SetLocalTransform(const Transform& transform);
	void SetWorldTransform(const Transform& transform);
	void SetWorldTranslation(const Vec3& translation);
	void SetWorldRotation(const Quat& rotation);
	void SetLocalTranslation(const Vec3& translation);
	void SetLocalRotation(const Quat& rotation);
	void TransformWorld(const Transform& transform);
	void TransformLocal(const Transform& transform);
	void TranslateLocal(const Vec3& translation);
	void TranslateWorld(const Vec3& translation);
	void RotateLocal(const Quat& rotation);
	void RotateWorld(const Quat& rotation);
	Transform GetLocalTransform() const { return m_localTransform; }
	Quat GetLocalRotation() const { return m_localTransform.rotation; }

	Transform GetWorldTransform();
	Mat4 GetLocalMatrix() const { return GetLocalTransform().ToMat4(); }
	Mat4 GetWorldMatrix() { return GetWorldTransform().ToMat4(); }

	auto& GetChildren() { return m_children; }
	Node* SearchChild(StringView name);

	Node* AddChild(StringView name) {
		m_children.emplace_back(new Node{ name });
		m_children.back()->m_parent = this;
		return m_children.back().get();
	}

	void AttachObject(SceneObject* obj) {
		obj->AttachTo(this);
		m_objects.push_back(obj);
	}

private:
	void InvalidateSubtreeWorldTransform();
	void CalculateLocalTransform();

private:
	Node* m_parent{};
	DynArray<Scoped<Node>> m_children{};
	DynArray<SceneObject*> m_objects{};

	bool m_isWorldTransformValid{ true };
	Transform m_localTransform{};
	Transform m_worldTransform{};
};

}

